/* -*-mode:c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
#include "network_namespace.hh"

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <dirent.h>
#include <errno.h>
#include <sys/mount.h>
#include <sys/stat.h>
#include <sched.h>

#include <memory>

#include "config.h"
#include "system_runner.hh"
#include "exception.hh"
#include "file_descriptor.hh"

using namespace std;

NetworkNamespace::NetworkNamespace( )
    : has_own_resolvconf_(false), resolvconf_file_(nullptr), has_entered_(false)
{
}


NetworkNamespace::~NetworkNamespace()
{
    /* If we want to cleanup resolv.conf tempfile we need to make sure it is unmounted first */
    if ( has_entered_ && has_own_resolvconf_ ) {

        if ( umount( "/etc/resolv.conf" ) < 0 ) {
            //TODO (worenga): proper RAII for mounts
            std::cerr <<  string("Unmounting... ") << resolvconf_file_->name() << " -> " << "/etc/resolv.conf" <<  " failed: " << strerror(errno) << "\n" << std::endl;
        }
    }

    //TODO (worenga): How can we redo the (mount/bind) namespace in a RAII manner?

}


void NetworkNamespace::create_resolvconf( const std::string & nameserver )
{
    if ( has_entered_ ) {
        throw runtime_error( string("Cannot create resolvconf after namespace has been entered.\n") );
    }

    resolvconf_file_.reset( std::move( new TempFile( "resolvconf" ) ) );
    has_own_resolvconf_ = true;
    resolvconf_file_->write( "# Ephemeral resolv.conf(5) file for glibc resolver(3) generated by mahimahi\n" );
    resolvconf_file_->write( "# DO NOT EDIT THIS FILE BY HAND -- CHANGES WILL BE LOST\n" );
    resolvconf_file_->write( "nameserver " + nameserver + "\n" );
}


void NetworkNamespace::enter()
{

    if ( unshare(CLONE_NEWNS) < 0 ) {
        throw runtime_error( string("unshare failed: ") + strerror(errno) + "\n " );
    }


    /* Don't let any mounts propagate back to the parent */
    if ( mount( "", "/", "none", MS_SLAVE | MS_REC, NULL ) ) {
        throw runtime_error( string("\"mount --make-rslave /\" failed: ") + strerror(errno) + "\n " );
    }

    if ( unshare(CLONE_NEWNET) < 0 ) {
        throw runtime_error( string("unshare failed: ") + strerror(errno) + "\n " );
    }

    has_entered_ = true;

    if ( has_own_resolvconf_ ) {

        if ( mount( resolvconf_file_->name().c_str() , "/etc/resolv.conf" , "none", MS_BIND, NULL ) < 0 ) {
            throw runtime_error( string("Bind ") + resolvconf_file_->name() + " -> " + "/etc/resolv.conf" + " failed: " + strerror(errno) + "\n" );
        }

    }

}
